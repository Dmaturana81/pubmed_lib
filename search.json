[
  {
    "objectID": "author.html",
    "href": "author.html",
    "title": "Author",
    "section": "",
    "text": "source\n\nAutor\n\n Autor (data)\n\n(dict) -> autor\nreceive a dictionary with information about autor. keys and types: Fname (str) Lname (str) name (str) emails (list) affiliations (str) identifier (list) countries (list) updated (datetime) n_papers (int) state (str)"
  },
  {
    "objectID": "parser.html",
    "href": "parser.html",
    "title": "Parser",
    "section": "",
    "text": "source\n\nparsePubmedData\n\n parsePubmedData (pubmeddata)\n\nReceive the xml section of PubmedData and return list of ids :param pubmeddata: :return:\n\nsource\n\n\nparseArticle\n\n parseArticle (article_info)\n\n:param article_info: dictionary from key Article of an Medline citation :return (dict): tuple of dictionary with information from paper and autors\n\nsource\n\n\nparse_email\n\n parse_email (affil_text)\n\nFind email from given string :param affil_text: :return str:\n\nsource\n\n\nparseMayorKeys\n\n parseMayorKeys (citationInfo)\n\n\nsource\n\n\nparseMeshKeys\n\n parseMeshKeys (citationInfo)\n\n\nsource\n\n\nparseKeys\n\n parseKeys (citationInfo)\n\n\nres = searchpb('Daniel Maturana', email=email, api_key=api_key)\npubs = fetch_details(res['IdList'])\n\n\ndef getParsedArticles(name, years = 3):\n    query = name + '[Author]'\n    results = searchpb(query, 100, maxdate = 2021, mindate = 2021 - years)\n    id_list = results['IdList']\n    if len(id_list) == 0:\n        return 0\n    papers = fetch_details(id_list)\n    n_papers = len(id_list)\n    print('checking in {} Articles'.format(n_papers))\n    articles=[]\n    for i, paperinfo in enumerate(papers['PubmedArticle']):\n        article = parse_paperinfo(paperinfo)\n        if int(article['published']) < 2020 - years:\n            # print('to old, article published on {}'.format(article['published']))\n            continue\n        articles.append(article)\n    print('Keeping with {} from last {} years'.format(len(articles), years))\n    return articles\n\ndef getParsedArticlesPeriod(name, maxdate=2020, years = 3, top_n=None, verbose=False):\n    query = name + '[Author]'\n    results = searchpb(query, 1000, maxdate = maxdate, mindate = maxdate - years)\n    id_list = results['IdList']\n    if len(id_list) == 0:\n        return ([],0)\n    papers = fetch_details(id_list)\n    n_papers = len(id_list)\n    if verbose:\n        print('checking in {} Articles'.format(n_papers))\n    articles=[]\n    for i, paperinfo in enumerate(papers['PubmedArticle']):\n        article = parse_paperinfo(paperinfo)\n        if maxdate < int(article['published'])  or int(article['published']) < maxdate -years :\n            # print('to old, article published on {}'.format(article['published']))\n            continue\n        articles.append(article)\n    if len(articles) == 0:\n        if verbose:\n            print('No articles in the time period')\n        return ([],n_papers)\n    elif top_n:\n        df = pd.DataFrame(articles).sort_values('published', ascending=False)\n        df = df.iloc[:top_n]\n        articles = df.to_dict('records')\n    if verbose:\n        print('Keeping with {} from last {} years'.format(len(articles), years))\n    return (articles, n_papers)\n\n\ndef fetchPubmedArticles(name, start, end, path, db_path = '/Volumes/Users/matu/Documents/Xcode/SFDC/db.pckl'):\n    \"\"\"Function to search in pubmed by name, start and end year.\n    It checks first in the database of abstracts downloaded before.\n    Create a csv file with the parsed pubmed results including abstract, authors, etc. (look at pubmed_utils)\n\n    return (pd.Dataframe) -> the DataFrame with all the information retrieved\"\"\"\n    db = loadDB(db_path)\n    if name not in db:\n        print('adding new year {} for {}'.format(start, name))\n        (pubmedData, total) = getParsedArticlesPeriod(name, start, end)\n        if pubmedData == 0:\n            db.update({name: {str(start):[total, 0]}})\n            return \n        else:\n            db.update({name: {str(start):[total, len(pubmedData)]}})\n    else:\n        if (str(start) in db[name]) and (str(end) in db[name]):\n            print(f\"{name} already in DB with year {start} - {end}, passing\")\n            df = pd.read_csv('{}/{}_{}_{}.csv'.format(path, name, start, start - end))\n            return df\n        else:\n            (pubmedData, total) = getParsedArticlesPeriod(name, start, end)\n            if pubmedData == 0:\n                db[name].update({str(start):[total, 0]})\n                return \n            else:\n                db[name].update({str(start):[total, len(pubmedData)]})\n    df = pd.DataFrame(pubmedData)\n    file_output = '{}/{}_{}_{}.csv'.format(path, name, start, start - end)\n    df.to_csv(file_output)\n    saveDB(db, db_path)\n    if df.shape[0] >= 10:\n        df = df.sort_values('published', ascending=False)\n        print('Using the 10 newer papers')\n        return df.iloc[:10]\n    return df\n\ndef retrieveArticles():\n    results = searchpb('Peter Ihnat[Author]')\n    papers = fetch_details(results['IdList'])\n    articles=[]\n    for i, paperinfo in enumerate(papers['PubmedArticle']):\n        article = parse_paperinfo(paperinfo)\n        articles.append(article)\n    return articles\n\n\nsource\n\n\nparse_paperinfo\n\n parse_paperinfo (paperinfo_xml:str)\n\n\nparam paperinfo_xml: :return:\n\n\n\nType\nDetails\n\n\n\n\npaperinfo_xml\nstr\nInformation\n\n\n\n\nsource\n\n\nparse_author_xml\n\n parse_author_xml (autor_xml)\n\n(dict)->dict Receive un diccionario con las informaciones de autor proveniente de pubmed xml article\n:param autor_xml: :return:\n\nsource\n\n\nfind_state\n\n find_state (location)\n\n(str)->str Find state of Brazl from the affiliation details :param location: :return:\n\nsource\n\n\nfind_country\n\n find_country (location)\n\nFind country from string"
  },
  {
    "objectID": "core.html",
    "href": "core.html",
    "title": "core",
    "section": "",
    "text": "source\n\nsearchpb\n\n searchpb (search_term:str, retmax:int=5000, retmode:str='xml',\n           sort:str='relevance', mindate:int=None, maxdate:int=None,\n           email=None, api_key=None)\n\nIt receive a query to be searched in pubmed and return the handler of the search\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nsearch_term\nstr\n\nQuery to be search in pubmed\n\n\nretmax\nint\n5000\nMaximum number of results to be retrieved\n\n\nretmode\nstr\nxml\nFormat of the returned data, options are xml,\n\n\nsort\nstr\nrelevance\nWay to sort the results\n\n\nmindate\nint\nNone\nInitial data to be search from, year\n\n\nmaxdate\nint\nNone\nFinal data to be search from, year\n\n\nemail\nNoneType\nNone\n\n\n\napi_key\nNoneType\nNone\n\n\n\n\n\nsource\n\n\nfetch_details\n\n fetch_details (IdList:list)\n\nIt receive a list of pubmedIds from a search, and retrieve all the details of those publications\n\n\n\n\nType\nDetails\n\n\n\n\nIdList\nlist\nList of pubmedIDs to fetch the details\n\n\n\n\nsource\n\n\ngetParsedArticles\n\n getParsedArticles (name, years=3)\n\n\nsource\n\n\ngetParsedArticlesPeriod\n\n getParsedArticlesPeriod (name, maxdate=2020, years=3, top_n=None,\n                          verbose=False)\n\n\nsource\n\n\nfetchPubmedArticles\n\n fetchPubmedArticles (name, start, end, path,\n                      db_path='/Volumes/Users/matu/Documents/Xcode/SFDC/db\n                      .pckl')\n\nFunction to search in pubmed by name, start and end year. It checks first in the database of abstracts downloaded before. Create a csv file with the parsed pubmed results including abstract, authors, etc. (look at pubmed_utils)\nreturn (pd.Dataframe) -> the DataFrame with all the information retrieved\n\nsource\n\n\nretrieveArticles\n\n retrieveArticles ()"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "pubmed_lib",
    "section": "",
    "text": "This file will become your README and also the index of your documentation."
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "pubmed_lib",
    "section": "Install",
    "text": "Install\npip install pubmed_lib"
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "pubmed_lib",
    "section": "How to use",
    "text": "How to use\nFill me in please! Donâ€™t forget code examples:\n\n1+1\n\n2"
  }
]